\section{Introduction}
A common problem with automated mobile software testing is testing mobile applications when the state of the device changes.  Testing the different states of an application has been enhanced with tools such as Espresso and Robotium \cite{optimusinformationinc2016}. The problem with this issue is that often, the state of a device will cause a catastrophic failure of a feature within an application when the state of a mobile device changes; therefore, it is more expensive to not test device states against application states at all.  Since the state of an application can be easily saved and the state of a device can be easily changed pro programatically, a solution that automatically tests application states with different device states is of great value.  For applications being used in different device states, such as a mapping application used outside of network range or medical applications using sensors for monitoring functions, application to device state testing this becomes an extremely important issue.  Some of these issues can even be life safety critical.  Additionally, the innovative ways applications are used with new hardware is only increasing.  State testing of applications with new hardware devices is a critical area of research to ensure that applications can continue to operate well. 

In addition to state testing, there is a strong need for innovative approaches to testing context aware applications \cite{Luo:2017:TLT:3139486.3130945}.  A context aware application is an application that is able to detect information about the device's physical environment using instrumentation and then do something with that information.  

"The field of mobile specific, black-box testing, however, remains thin." \cite{paulovsky2017high}  That is the reasoning behind this endeavor to make easier testing tools that easily test the interaction of device states with applications states.  

We have developed a Mobile application called "TADS" (Test Application to Device State) that uses a Mobile development UI tester to test the Mobile application against multiple states and sub-states of the device \cite{366932}.  TADS is primarily concerned with identifying errors caused by changing device states and not as concerned with identifying why the state change caused a failure.

\section{Research Contributions}
This work demonstrates that a library for doing state testing of devices that can be run with espresso is highly beneficial and easy to make.  This research contributes a tool that can be used right now for anyone wanting to improve their test suites to include device state testing.. 

The second contribution this work makes is a very simple way for testing context-aware applications' handling of instrumentation state changes. The work done in \cite{Luo:2017:TLT:3139486.3130945} produces test data for context applications, this work tests the affect of changing the state of the instruments used by those applications.  A DSC can be easily generated that changes the states of the instruments that the context aware application uses in order to ensure changing instrumentation states will not cause a failure. 

\section{Background}
As of the writing of this paper, there is not any research available on building out an automatic device state testing utility.  In order to understand this project a few items must be known ahead of time.  

Espresso, an android testing application, has an excellent tool for testing Mobile application UI's \cite{nolan2015agile}.  The tool records what is happening at a code level while a user performs different actions using the UI.  This enables a working application to have a test automatically generated that can then be run at a later time which can be used to create a regression test suite.  This actually enables states of the application to be tested without having to use any form of state machines or modeling.  This tool called "Test Recorder" will be foundational to TADS. 


\section{Related Work}
There are several tools developed that can capture various information of an application and store said information for later tests.  These tools can be leveraged to create interesting app states instead of simple object states.  For instance Paulovsky et al. \cite{7962332} built a tool that automatically captures UI information as a user utilizes an application. 

The most similar work to TADS is called Barista by Fazzini et al. \cite{7927971}.  They made a tool that can store UI information and then auto generate oracles that then get scripted into an Espresso test script for later use as a test case.  This tool could be used to run test cases as the DSCs execute as the state instead of static properties being evaluated. This solution cannot evaluate device state; though, the researchers have added doing so to their future works section.   

Many others, such as \cite{7927971} have made tools for recording tests that can be later executed in ways that are platform independent which is a nice utility that we will not be concerned with in this work.  Others have made unit level state testing models such as MilaniFard el al. \cite{MilaniFard:2014:LET:2642937.2642991} in which the state of the application is tested by automatically building a model using a dynamic and static crawler and then running that created model against a verification algorithm.  These researchers developed a way to use model testing to find security vulnerabilities \cite{7911333}.  Some have used machine learning to find the states of an application that are probably of value to test that have not been tested and make a model of those states for testing \cite{Choi:2013:GGT:2544173.2509552}.


\section{Past Research Challenges}
There are numerous challenges to this research.  The main challenge is that I am not up to speed on how espresso works from a low level perspective.  The next issue is that I am not aware of how Android Studio works at a very low level either.  In order to exploit architectural features one must be aware of how these items work precisely.  

For instance, my first attempt was to make a set of functions in a name space that would be called iteratively with a loop added to the test case.  This had numerous issues and I could not make it work.  The problem was that I had to force the application back to the beginning each iteration.  There was not a good function that was easily called to do so because of the nature of the espresso and AndroidJUnit4 test runners.  The code that I was embedding was actually inside of the test and so it was impossible to change states and then rerun the application tests from within the tests; otherwise it would have become recursive and app state would have created a whole host of new problems.  

My second approach involved making a separate test class that would call the test class that espresso made.  There were several problems with this.  The biggest problem was that there are these preconditions that must be set using annotations.  A "rule" gets set and that must come before the test.  The rule must be scoped to the test class and cannot be scoped to the function being called.  The way that AndroidJUnit executes the tests is that it sees the "@RunWith" annotation which is tied to a class, then the "@Rule" annotation, then the "@Test" annotation.  It executes in that order.  So, when a new test class is generated, those idioms must be used. I discovered that trying to loop through one test class within another was not easily accomplished and could possibly be impossible.  I shifted my approach to the current implementation.


\section{Implementation}
The main purpose of this Application is to simplify testing of different device states with the application.  There are preloaded "device state changes" (DSCs) that can be used in a test suite to test the app states that are chosen for testing.  A DSC is a test case that starts with a device state then runs the test cases then changes the Devices state then runs the tests again.  A few examples of DSCs are: airplane mode off, sample the app state, switch airplane mode to on, re-sample the app state to evaluate.

I shifted the approach to be able to implement the DSCs to a BATCH script using ADB from the command line.  This approach works well because intents and actions can be called from the command line.  The command to run the tests can be changed to either run all tests in the project or to run individual tests.  

The solution is built on Microsoft Power Shell and written as Power Shell scripts.  Power Shell was decided on to enforce DRY and SOLID principles without the convolution of building an executable program that is compiled.  

The solution is run by running a powershell script from the command line with parameters that are the name of your solution and tests.

\section{Future Research Challenges and Possible Solutions}
Scripting does not offer the robust programming capabilities that true object oriented architectures offer.  Building classes to iterate different device states and enforcing a true DRY and SOLID scripting library may prove to be a challenge.  Additionally, the automated testing tools available for BATCH files are limited.  One possible solution to this problem is to implement a .NET WPF project that calls the ADB API and can be used to execute the automated device state tests.  

Another challenge is that commands do not exist for ADB to change proprietary device states.  Figuring out how to instantiate hardware devices from the command interface will prove extremely difficult and more manual testing will be required in those instances.   

A third challenge to overcome will be making the logging and debugging apparatus in a way that it is easy to use and robust.  Currently only the DSC that was in play during the execution of the tests will be recorded and debug information from the ADB driver.  It is unknown to the research team at this time how much of the Android debugging information actually comes through the ADB driver.  The research team will have to tap into android logs and capture pertinent information or some other solution to capturing pertinent information will have to be developed.  This task is outside the scope of this current project (Note to class members, this will probably get moved to future research section).\\ \\

Barista \cite{7927971} provides a better script generation tool than Espresso.  Integrating TADS to run Barista could prove to be a valuable endeavor.  

We also hope to expand the instrumentation capabilities to include wearable devices such as Android watch or even google glass for state testing with apps running on those devices.

We intend to look at how much of a problem device state testing is in industry by interviewing several different mobile applications developers to ask them  

The last future research we are considering at this time is to investigate how device state affects installs.  Installations can be affected by the state of different items running on a device and building a test script that installs an application and running that installation on devices with different states may prove valuable; though, some research into whether or not industry struggles with installations being affected by state would be an interesting approach.  

\begin{tabular}{ |p{3cm}||p{3cm}| }
	\hline
	\multicolumn{2}{|c|}{Timeline} \\
	\hline
		10/16 & Investigate Classes scripting \\
		\hline
	10/23&   Figure out more ADB device commands to change states  \\
	\hline
	10/30 &Implement with more commands \\
	\hline
	11/6    &Capture Logging	 \\
	\hline
	11/13& Well defined Metrics \\
	\hline
	11/20& Finding apps to test library with  \\
	\hline
	11/27& Testing and recording \\
	\hline
	12/4 & Refining \\
	\hline
	12/11 & Refining / turn in \\
	\hline
	
\end{tabular}
\\
\section{Threats to Validity}
One serious threat to this work is that the automated test scripts built in Espresso can be affected by state changes \cite{7927971} which can cause a failure in the test due to the script's failure and not the application's.